<html>
<head>
<title>jEdit Syntax Colorizing System</title>
</head>

<body>

<h1>jEdit Syntax Colorizing System</h1>

<ul>
<li><a href=#intro>Introduction</a>
<li><a href=#over>Overview</a>
<li><a href=#extending>Writing New TokenMarkers</a>
<li><a href=#using>Using jEdit's Syntax Colorizing in Other Applications</a>
</ul>

<a name=intro>
<h1>Introduction</h1>
</a>

This file has information about extending and using jEdit's syntax colorizing
system.

<a name=over>
<h1>Overview</h1>
</a>

jEdit's syntax colorizing system is composed of several layers. At the
lowest level is an instance of
<a href=api/org.gjt.sp.jedit.syntax.TokenMarker.html>
org.gjt.sp.jedit.syntax.TokenMarker</a>, which parses lines of text and
returns a linked list of tokens, each token containing a token type and
length.<p>

Further up is the <a href=api/org.gjt.sp.jedit.syntax.SyntaxView.html>
org.gjt.sp.jedit.syntax.SyntaxView</a> class, which paints tokenized
lines.<p>

The <a href=api/org.gjt.sp.jedit.syntax.SyntaxEditorKit.html>
org.gjt.sp.jedit.syntax.SyntaxEditorKit</a> creates instances of
the <code>SyntaxView</code> class.

<a name=extending>
<h1>Writing New TokenMarkers</h1>
</a>

Extending jEdit's syntax colorizing system is actually quite easy.
One needs to implement a subclass of the
<a href=api/org.gjt.sp.jedit.syntax.TokenMarker.html>
org.gjt.sp.jedit.syntax.TokenMarker</a> class.<p>

Once a token marker exists, an implementation of
<a href=api/org.gjt.sp.jedit.syntax.Mode.html>
org.gjt.sp.jedit.syntax.Mode</a> needs to be provided, that returns
a new instance of the token marker in the <code>createTokenMarker</code>
method.

Because there are many tricks you can use when writing token markers,
studying the source to one can be a great help. The two most complicated
token markers are CTokenMarker.java and SQLTokenMarker.java - they use
region matching, keyword maps, and many other useful techniques.

<a name=using>
<h1>Using jEdit's Syntax Colorizing in Other Applications</h1>
</a>

jEdit's syntax colorizing component can be embedded in other applications.
The easiest way to describe how this is done is with a live code
example:

<pre>
SyntaxTextArea textArea = new SyntaxTextArea();

<font color=red>/* Enable bracket highlighting (optional) */</font>
textArea.setBracketHighlight(true);

<font color=red>/* Fetch it's document */</font>
DefaultSyntaxDocument document =
	(DefaultSyntaxDocument)textArea.getDocument();

<font color=red>/* Give it a token marker */</font>
document.setTokenMarker(new JavaTokenMarker());

<font color=red>/* Fill in the color table */</font>
document.getColors().put(Token.COMMENT1,Color.red);
document.getColors().put(Token.COMMENT2,Color.red);
document.getColors().put(Token.LITERAL1,Color.gray);
document.getColors().put(Token.LITERAL2,Color.gray);
document.getColors().put(Token.LABEL,Color.darkGray);
document.getColors().put(Token.KEYWORD1,Color.blue);
document.getColors().put(Token.KEYWORD2,Color.magenta);
document.getColors().put(Token.KEYWORD3,Color.green);
document.getColors().put(Token.OPERATOR,Color.orange);
document.getColors().put(Token.INVALID,Color.red);
</pre>

Basically, it boils down to creating an
<a href=api/org.gjt.sp.jedit.syntax.SyntaxTextArea.html>
org.gjt.sp.jedit.syntax.SyntaxTextArea</a> instance
and setting the appropriate properties of it's document.<p>

By default, <code>SyntaxTextArea</code> uses an
<a href=api/org.gjt.sp.jedit.syntax.DefaultSyntaxDocument.html>
org.gjt.sp.jedit.syntax.DefaultSyntaxDocument</a> as it's document.
In some situations, <code>DefaultSyntaxDocument</code> is not
appropriate - the lower level
<a href=api/org.gjt.sp.jedit.syntax.SyntaxDocument.html>
org.gjt.sp.jedit.syntax.SyntaxDocument</a> interface can be used
instead.

</body>
</html>
